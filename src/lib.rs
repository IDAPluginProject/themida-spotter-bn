mod themida;

use std::sync::atomic::{AtomicU64, Ordering};

use binaryninja::{
    backgroundtask::BackgroundTask,
    binaryview::{BinaryView, BinaryViewExt},
    command::register,
    function::Function,
    logger,
};
use log::{debug, info};
use rayon::prelude::*;

use themida::ThemidaSpotterCommand;

pub type CodeEntryDestRange = std::ops::Range<u64>;

const THEMIDA_SPOTTER_PLUGIN_NAME: &str = "themida-spotter-bn";
const THEMIDA_SPOTTER_TAG_NAME: &str = "Themida's obfuscated code entries";

#[derive(Debug)]
pub enum CodeEntryDescription {
    // VMENTER (RVA)
    VMEnter(u64),
    // MUTENTER (RVA)
    MUTEnter(u64),
}

impl CodeEntryDescription {
    pub fn rva(&self) -> u64 {
        match self {
            Self::VMEnter(rva) => *rva,
            Self::MUTEnter(rva) => *rva,
        }
    }

    pub fn type_name(&self) -> &str {
        match self {
            Self::VMEnter(_) => "Code entry (Virtualized)",
            Self::MUTEnter(_) => "Code entry (Mutated)",
        }
    }
}

pub fn search_for_code_entries<
    F: Send
        + Sync
        + 'static
        + Fn(&BinaryView, &Function, &[CodeEntryDestRange]) -> Option<CodeEntryDescription>,
>(
    view: &BinaryView,
    analyze_function: F,
    target_sections: Vec<CodeEntryDestRange>,
) {
    let view = view.to_owned();
    let _thread = std::thread::spawn(move || {
        if let Ok(mut task) = BackgroundTask::new(
            format!("({}) Initializing...", THEMIDA_SPOTTER_PLUGIN_NAME),
            true,
        ) {
            search_for_code_entries_task(
                view.as_ref(),
                analyze_function,
                target_sections,
                &mut task,
            );

            task.set_progress_text("");
            task.finish();
        }
    });
}

fn search_for_code_entries_task<
    F: Send + Sync + Fn(&BinaryView, &Function, &[CodeEntryDestRange]) -> Option<CodeEntryDescription>,
>(
    view: &BinaryView,
    analyze_function: F,
    target_sections: Vec<CodeEntryDestRange>,
    task: &mut BackgroundTask,
) {
    info!("Searching for obfuscated code entry patterns...");

    let function_count = view.functions().len();
    debug!("Processing {} functions.", function_count);
    let current_progress = AtomicU64::new(1);
    let code_entry_descriptions_opt = view
        .functions()
        .par_iter()
        .try_fold(Vec::new, |mut acc: Vec<CodeEntryDescription>, func| {
            // Cancel task if needed
            if task.is_cancelled() {
                return None;
            }

            if let Some(entry_desc) = analyze_function(view, func.as_ref(), &target_sections) {
                acc.push(entry_desc);
            }
            // Update task's progress
            task.set_progress_text(format!(
                "({}) {} / {} functions processed",
                THEMIDA_SPOTTER_PLUGIN_NAME,
                current_progress.load(Ordering::Acquire),
                function_count
            ));
            current_progress.fetch_add(1, Ordering::Acquire);

            Some(acc)
        })
        .try_reduce(
            Vec::new,
            |mut a: Vec<CodeEntryDescription>, mut b: Vec<CodeEntryDescription>| {
                a.append(&mut b);
                Some(a)
            },
        );

    if let Some(code_entry_descriptions) = code_entry_descriptions_opt {
        // Get or create tag type
        let vm_entry_tag_type = view
            .get_tag_type(THEMIDA_SPOTTER_TAG_NAME)
            .unwrap_or_else(|| {
                // Note(ergrelet): due to a bug in Binja's Rust API, `icon`
                // actually sets the name of the tag.
                // FIXME: Update the code to set an actual icon when the bug is fixed upstream.
                view.create_tag_type(THEMIDA_SPOTTER_TAG_NAME, THEMIDA_SPOTTER_TAG_NAME)
            });

        // Create tags for each obfuscated code entry found (if any)
        code_entry_descriptions.iter().for_each(|code_entry_desc| {
            view.add_tag(
                code_entry_desc.rva(),
                &vm_entry_tag_type,
                code_entry_desc.type_name(),
                false, // Won't be added to the undo buffer
            );
        });

        info!(
            "Found {} obfuscated code entry locations. Tags have been set at the corresponding addresses.",
            code_entry_descriptions.len()
        );
    } else {
        info!("Operation was cancelled");
    }
}

#[no_mangle]
pub extern "C" fn UIPluginInit() -> bool {
    if logger::init(log::LevelFilter::Info).is_err() {
        return false;
    }

    register(
        format!(
            r"{}\Find obfuscated code entries (3.x)",
            THEMIDA_SPOTTER_PLUGIN_NAME
        ),
        "Look for obfuscated code entry patterns generated by Themida 3.x".to_string(),
        ThemidaSpotterCommand {},
    );

    true
}
